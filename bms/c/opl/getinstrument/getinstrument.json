{"Includes": ["#include <stdio.h>\n", "#include <stdint.h>\n", "#include <stdlib.h> /* calloc() */\n", "#include <string.h> /* strdup() */\n"], "Defines": ["#define OPL_EMU_REGISTERS_OPERATORS ( OPL_EMU_REGISTERS_CHANNELS * 2 )\n", "#define OPL_EMU_REGISTERS_WAVEFORMS 8\n", "#define OPL_EMU_REGISTERS_CHANNELS 18\n", "#define OPL_EMU_REGISTERS_REGISTERS 0x200\n", "#define OPL_EMU_REGISTERS_WAVEFORM_LENGTH 0x400\n"], "TypeDefs": ["typedef struct opl_t opl_t;"], "Globals": [], "Structs": ["struct opl_emu_registers\n{\n\t// internal state\n\tuint16_t m_lfo_am_counter;            // LFO AM counter\n\tuint16_t m_lfo_pm_counter;            // LFO PM counter\n\tuint32_t m_noise_lfsr;                // noise LFSR state\n\tuint8_t m_lfo_am;                     // current LFO AM value\n\tuint8_t m_regdata[OPL_EMU_REGISTERS_REGISTERS];         // register data\n\tuint16_t m_waveform[OPL_EMU_REGISTERS_WAVEFORMS][OPL_EMU_REGISTERS_WAVEFORM_LENGTH]; // waveforms\n};", "struct opl_emu_opdata_cache\n{\n\t// set phase_step to this value to recalculate it each sample; needed\n\t// in the case of PM LFO changes\n\n\tuint32_t phase_step;              // phase step, or OPL_EMU_PHASE_STEP_DYNAMIC if PM is active\n\tuint32_t total_level;             // total level * 8 + KSL\n\tuint32_t block_freq;              // raw block frequency value (used to compute phase_step)\n\tint32_t detune;                   // detuning value (used to compute phase_step)\n\tuint32_t multiple;                // multiple value (x.1, used to compute phase_step)\n\tuint32_t eg_sustain;              // sustain level, shifted up to envelope values\n\tuint8_t eg_rate[OPL_EMU_EG_STATES];       // envelope rate, including KSR\n\tuint8_t eg_shift;                 // envelope shift amount\n};", "struct opl_emu_fm_operator\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tuint32_t m_opoffs;                     // operator offset in registers\n\tuint32_t m_phase;                      // current phase value (10.10 format)\n\tuint16_t m_env_attenuation;            // computed envelope attenuation (4.6 format)\n\tenum opl_emu_envelope_state m_env_state;            // current envelope state\n\tuint8_t m_key_state;                   // current key state: on or off (bit 0)\n\tuint8_t m_keyon_live;                  // live key on state (bit 0 = direct, bit 1 = rhythm, bit 2 = CSM)\n\tstruct opl_emu_opdata_cache m_cache;                  // cached values for performance\n\tstruct opl_emu_registers* m_regs;                  // direct reference to registers\n};", "struct opl_emu_fm_channel\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tint16_t m_feedback[2];                 // feedback memory for operator 1\n\tint16_t m_feedback_in;         // next input value for op 1 feedback (set in output)\n\tstruct opl_emu_fm_operator *m_op[4];    // up to 4 operators\n\tstruct opl_emu_registers* m_regs;                  // direct reference to registers\n};", "typedef struct opl_timbre_t {\n  unsigned long modulator_E862, carrier_E862;\n  unsigned char modulator_40, carrier_40;\n  unsigned char feedconn;\n  signed char finetune;\n  unsigned char notenum;\n  signed short noteoffset;\n} opl_timbre_t;", "struct opl_emu_t\n{\n\tuint32_t m_env_counter;          // envelope counter; low 2 bits are sub-counter\n\tuint8_t m_status;                // current status register\n\tuint8_t m_timer_running[2];      // current timer running state\n\tuint32_t m_active_channels;      // mask of active channels (computed by prepare)\n\tuint32_t m_modified_channels;    // mask of channels that have been modified\n\tuint32_t m_prepare_count;        // counter to do periodic prepare sweeps\n\tstruct opl_emu_registers m_regs;             // register accessor\n\tstruct opl_emu_fm_channel m_channel[OPL_EMU_REGISTERS_CHANNELS]; // channel pointers\n\tstruct opl_emu_fm_operator m_operator[OPL_EMU_REGISTERS_OPERATORS]; // operator pointers\n};", "struct voicealloc_t {\n  unsigned short priority;\n  signed short timbreid;\n  signed char channel;\n  signed char note;\n  unsigned char voiceindex; /* 1 if 2nd voice for OP2 soundbank instrument, 0 otherwise */\n};", "struct opl_t {\n  signed char notes2voices[16][128][2]; /* keeps the map of channel:notes -> voice allocations */\n  unsigned short channelpitch[16];      /* per-channel pitch level */\n  unsigned short channelvol[16];        /* per-channel pitch level */\n  struct voicealloc_t voices2notes[18]; /* keeps the map of what voice is playing what note/channel currently */\n  unsigned char channelprog[16];        /* programs (patches) assigned to channels */\n  int opl3; /* flag indicating whether or not the sound module is OPL3-compatible or only OPL2 */\n  struct opl_emu_t opl_emu;\n  struct opl_timbre_t opl_gmtimbres[ 256 ];\n  struct opl_timbre_t opl_gmtimbres_voice2[ 256 ]; /* second voice included in OP2 format */\n  int is_op2; /* true if OP2 soundbank */\n  enum op2_flags_t op2_flags[ 256 ]; /* OP2 format flags */\n};"], "Function Declarations": ["static int getinstrument(opl_t* opl, int channel, int note) ;"], "Function Implementations": ["static int getinstrument(opl_t* opl, int channel, int note) {\n  if ((note < 0) || (note > 127) || (channel > 15)) return(-1);\n  if (channel == 9) { /* the percussion channel requires special handling */\n    if (opl->is_op2)\n      return 128 + note - 35;\n    else\n      return(128 | note);\n  }\n  return(opl->channelprog[channel]);\n}"], "Enums": ["enum opl_emu_envelope_state\n{\n\tOPL_EMU_EG_ATTACK = 1,\n\tOPL_EMU_EG_DECAY = 2,\n\tOPL_EMU_EG_SUSTAIN = 3,\n\tOPL_EMU_EG_RELEASE = 4,\n\tOPL_EMU_EG_STATES = 6\n};", "enum op2_flags_t {\n  OP2_FIXEDPITCH = 1,\n  OP2_UNUSED = 2, /* technically delayed vibrato https://moddingwiki.shikadi.net/wiki/OP2_Bank_Format */\n  OP2_DOUBLEVOICE = 4,\n};"]}