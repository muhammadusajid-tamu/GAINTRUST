{"Includes": ["#include <stdio.h>\n", "#include <stdint.h>\n", "#include <stdlib.h> /* calloc() */\n", "#include <string.h> /* strdup() */\n"], "Defines": [], "TypeDefs": [], "Globals": [], "Structs": [], "Function Declarations": ["uint32_t opl_emu_bitfield(uint32_t value, int start, int length )\n;", "static uint32_t opl_emu_opl_compute_phase_step(uint32_t block_freq, uint32_t multiple, int32_t lfo_raw_pm)\n;"], "Function Implementations": ["uint32_t opl_emu_bitfield(uint32_t value, int start, int length )\n{\n\treturn (value >> start) & ((1 << length) - 1);\n}", "static uint32_t opl_emu_opl_compute_phase_step(uint32_t block_freq, uint32_t multiple, int32_t lfo_raw_pm)\n{\n\t// OPL phase calculation has no detuning, but uses FNUMs like\n\t// the OPN version, and computes PM a bit differently\n\n\t// extract frequency number as a 12-bit fraction\n\tuint32_t fnum = opl_emu_bitfield(block_freq, 0, 10) << 2;\n\n\t// apply the phase adjustment based on the upper 3 bits\n\t// of FNUM and the PM depth parameters\n\tfnum += (lfo_raw_pm * opl_emu_bitfield(block_freq, 7, 3)) >> 1;\n\n\t// keep fnum to 12 bits\n\tfnum &= 0xfff;\n\n\t// apply block shift to compute phase step\n\tuint32_t block = opl_emu_bitfield(block_freq, 10, 3);\n\tuint32_t phase_step = (fnum << block) >> 2;\n\n\t// apply frequency multiplier (which is cached as an x.1 value)\n\treturn (phase_step * multiple) >> 1;\n}"], "Enums": []}