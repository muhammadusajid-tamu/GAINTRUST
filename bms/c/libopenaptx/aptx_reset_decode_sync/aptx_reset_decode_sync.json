{"Includes": ["#include <stdint.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n"], "Defines": ["#define LATENCY_SAMPLES 90\n", "#define NB_FILTERS 2\n", "#define NB_SUBBANDS 4\n", "#define FILTER_TAPS 16\n"], "TypeDefs": [], "Globals": [], "Structs": ["struct aptx_filter_signal {\n    int32_t buffer[2*FILTER_TAPS];\n    uint8_t pos;\n};", "struct aptx_prediction {\n    int32_t prev_sign[2];\n    int32_t s_weight[2];\n    int32_t d_weight[24];\n    int32_t pos;\n    int32_t reconstructed_differences[48];\n    int32_t previous_reconstructed_sample;\n    int32_t predicted_difference;\n    int32_t predicted_sample;\n};", "struct aptx_invert_quantize {\n    int32_t quantization_factor;\n    int32_t factor_select;\n    int32_t reconstructed_difference;\n};", "struct aptx_quantize {\n    int32_t quantized_sample;\n    int32_t quantized_sample_parity_change;\n    int32_t error;\n};", "struct aptx_QMF_analysis {\n    struct aptx_filter_signal outer_filter_signal[NB_FILTERS];\n    struct aptx_filter_signal inner_filter_signal[NB_FILTERS][NB_FILTERS];\n};", "struct aptx_channel {\n    int32_t codeword_history;\n    int32_t dither_parity;\n    int32_t dither[NB_SUBBANDS];\n\n    struct aptx_QMF_analysis qmf;\n    struct aptx_quantize quantize[NB_SUBBANDS];\n    struct aptx_invert_quantize invert_quantize[NB_SUBBANDS];\n    struct aptx_prediction prediction[NB_SUBBANDS];\n};", "struct aptx_context {\n    size_t decode_sync_packets;\n    size_t decode_dropped;\n    struct aptx_channel channels[NB_CHANNELS];\n    uint8_t hd;\n    uint8_t sync_idx;\n    uint8_t encode_remaining;\n    uint8_t decode_skip_leading;\n    uint8_t decode_sync_buffer_len;\n    unsigned char decode_sync_buffer[6];\n};"], "Function Declarations": ["void aptx_reset(struct aptx_context *ctx)\n;", "static void aptx_reset_decode_sync(struct aptx_context *ctx)\n;"], "Function Implementations": ["void aptx_reset(struct aptx_context *ctx)\n{\n    const uint8_t hd = ctx->hd;\n    unsigned i, chan, subband;\n    struct aptx_channel *channel;\n    struct aptx_prediction *prediction;\n\n    for (i = 0; i < sizeof(*ctx); i++)\n        ((unsigned char *)ctx)[i] = 0;\n\n    ctx->hd = hd;\n    ctx->decode_skip_leading = (LATENCY_SAMPLES+3)/4;\n    ctx->encode_remaining = (LATENCY_SAMPLES+3)/4;\n\n    for (chan = 0; chan < NB_CHANNELS; chan++) {\n        channel = &ctx->channels[chan];\n        for (subband = 0; subband < NB_SUBBANDS; subband++) {\n            prediction = &channel->prediction[subband];\n            prediction->prev_sign[0] = 1;\n            prediction->prev_sign[1] = 1;\n        }\n    }\n}", "static void aptx_reset_decode_sync(struct aptx_context *ctx)\n{\n    const size_t decode_dropped = ctx->decode_dropped;\n    const size_t decode_sync_packets = ctx->decode_sync_packets;\n    const uint8_t decode_sync_buffer_len = ctx->decode_sync_buffer_len;\n    unsigned char decode_sync_buffer[6];\n    unsigned i;\n\n    for (i = 0; i < 6; i++)\n        decode_sync_buffer[i] = ctx->decode_sync_buffer[i];\n\n    aptx_reset(ctx);\n\n    for (i = 0; i < 6; i++)\n        ctx->decode_sync_buffer[i] = decode_sync_buffer[i];\n\n    ctx->decode_sync_buffer_len = decode_sync_buffer_len;\n    ctx->decode_sync_packets = decode_sync_packets;\n    ctx->decode_dropped = decode_dropped;\n}"], "Enums": ["enum channels {\n    LEFT,\n    RIGHT,\n    NB_CHANNELS\n};"]}