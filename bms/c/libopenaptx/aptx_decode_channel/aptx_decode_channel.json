{"Includes": ["#include <stdint.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n"], "Defines": ["#define NB_FILTERS 2\n", "#define NB_SUBBANDS 4\n", "#define FILTER_TAPS 16\n"], "TypeDefs": [], "Globals": ["static const int32_t aptx_qmf_inner_coeffs[NB_FILTERS][FILTER_TAPS] = {\n    {\n       1033, -584, -13592, 61697, -171156, 381799, -828088, 3962579,\n       985888, -226954, 39048, 11990, -14203, 4966, 973, -1268,\n    },\n    {\n      -1268, 973, 4966, -14203, 11990, 39048, -226954, 985888,\n      3962579, -828088, 381799, -171156, 61697, -13592, -584, 1033,\n    },\n};", "static const int32_t aptx_qmf_outer_coeffs[NB_FILTERS][FILTER_TAPS] = {\n    {\n        730, -413, -9611, 43626, -121026, 269973, -585547, 2801966,\n        697128, -160481, 27611, 8478, -10043, 3511, 688, -897,\n    },\n    {\n        -897, 688, 3511, -10043, 8478, 27611, -160481, 697128,\n        2801966, -585547, 269973, -121026, 43626, -9611, -413, 730,\n    },\n};"], "Structs": ["struct aptx_filter_signal {\n    int32_t buffer[2*FILTER_TAPS];\n    uint8_t pos;\n};", "struct aptx_prediction {\n    int32_t prev_sign[2];\n    int32_t s_weight[2];\n    int32_t d_weight[24];\n    int32_t pos;\n    int32_t reconstructed_differences[48];\n    int32_t previous_reconstructed_sample;\n    int32_t predicted_difference;\n    int32_t predicted_sample;\n};", "struct aptx_invert_quantize {\n    int32_t quantization_factor;\n    int32_t factor_select;\n    int32_t reconstructed_difference;\n};", "struct aptx_quantize {\n    int32_t quantized_sample;\n    int32_t quantized_sample_parity_change;\n    int32_t error;\n};", "struct aptx_QMF_analysis {\n    struct aptx_filter_signal outer_filter_signal[NB_FILTERS];\n    struct aptx_filter_signal inner_filter_signal[NB_FILTERS][NB_FILTERS];\n};", "struct aptx_channel {\n    int32_t codeword_history;\n    int32_t dither_parity;\n    int32_t dither[NB_SUBBANDS];\n\n    struct aptx_QMF_analysis qmf;\n    struct aptx_quantize quantize[NB_SUBBANDS];\n    struct aptx_invert_quantize invert_quantize[NB_SUBBANDS];\n    struct aptx_prediction prediction[NB_SUBBANDS];\n};"], "Function Declarations": ["static inline int32_t clip_intp2(int32_t a, unsigned p)\n;", "static inline int64_t rshift64(int64_t value, unsigned shift) ;", "static inline int32_t rshift64_clip24(int64_t value, unsigned shift) ;", "static inline int32_t aptx_qmf_convolution(const struct aptx_filter_signal *signal,\n                                           const int32_t coeffs[FILTER_TAPS],\n                                           unsigned shift)\n;", "static inline void aptx_qmf_filter_signal_push(struct aptx_filter_signal *signal,\n                                               int32_t sample)\n;", "static inline void aptx_qmf_polyphase_synthesis(struct aptx_filter_signal signal[NB_FILTERS],\n                                                const int32_t coeffs[NB_FILTERS][FILTER_TAPS],\n                                                unsigned shift,\n                                                int32_t low_subband_input,\n                                                int32_t high_subband_input,\n                                                int32_t samples[NB_FILTERS])\n;", "static void aptx_qmf_tree_synthesis(struct aptx_QMF_analysis *qmf,\n                                    const int32_t subband_samples[NB_SUBBANDS],\n                                    int32_t samples[4])\n;", "static void aptx_decode_channel(struct aptx_channel *channel, int32_t samples[4])\n;"], "Function Implementations": ["static inline int32_t clip_intp2(int32_t a, unsigned p)\n{\n    if (((uint32_t)a + ((uint32_t)1 << p)) & ~(((uint32_t)2 << p) - 1))\n        return (a >> 31) ^ ((1 << p) - 1);\n    else\n        return a;\n}", "static inline int64_t rshift64(int64_t value, unsigned shift) { const int64_t rounding = (int64_t)1 << (shift - 1); const int64_t mask = ((int64_t)1 << (shift + 1)) - 1; return ((value + rounding) >> shift) - ((value & mask) == rounding); }", "static inline int32_t rshift64_clip24(int64_t value, unsigned shift) { return clip_intp2((int32_t)rshift64(value, shift), 23); }", "static inline int32_t aptx_qmf_convolution(const struct aptx_filter_signal *signal,\n                                           const int32_t coeffs[FILTER_TAPS],\n                                           unsigned shift)\n{\n    const int32_t *sig = &signal->buffer[signal->pos];\n    int64_t e = 0;\n    unsigned i;\n\n    for (i = 0; i < FILTER_TAPS; i++)\n        e += (int64_t)sig[i] * (int64_t)coeffs[i];\n\n    return rshift64_clip24(e, shift);\n}", "static inline void aptx_qmf_filter_signal_push(struct aptx_filter_signal *signal,\n                                               int32_t sample)\n{\n    signal->buffer[signal->pos            ] = sample;\n    signal->buffer[signal->pos+FILTER_TAPS] = sample;\n    signal->pos = (signal->pos + 1) & (FILTER_TAPS - 1);\n}", "static inline void aptx_qmf_polyphase_synthesis(struct aptx_filter_signal signal[NB_FILTERS],\n                                                const int32_t coeffs[NB_FILTERS][FILTER_TAPS],\n                                                unsigned shift,\n                                                int32_t low_subband_input,\n                                                int32_t high_subband_input,\n                                                int32_t samples[NB_FILTERS])\n{\n    int32_t subbands[NB_FILTERS];\n    unsigned i;\n\n    subbands[0] = low_subband_input + high_subband_input;\n    subbands[1] = low_subband_input - high_subband_input;\n\n    for (i = 0; i < NB_FILTERS; i++) {\n        aptx_qmf_filter_signal_push(&signal[i], subbands[1-i]);\n        samples[i] = aptx_qmf_convolution(&signal[i], coeffs[i], shift);\n    }\n}", "static void aptx_qmf_tree_synthesis(struct aptx_QMF_analysis *qmf,\n                                    const int32_t subband_samples[NB_SUBBANDS],\n                                    int32_t samples[4])\n{\n    int32_t intermediate_samples[4];\n    unsigned i;\n\n    /* Join 4 subbands into 2 intermediate subbands upsampled to 2 samples. */\n    for (i = 0; i < 2; i++)\n        aptx_qmf_polyphase_synthesis(qmf->inner_filter_signal[i],\n                                     aptx_qmf_inner_coeffs, 22,\n                                     subband_samples[2*i+0],\n                                     subband_samples[2*i+1],\n                                     &intermediate_samples[2*i]);\n\n    /* Join 2 samples from intermediate subbands upsampled to 4 samples. */\n    for (i = 0; i < 2; i++)\n        aptx_qmf_polyphase_synthesis(qmf->outer_filter_signal,\n                                     aptx_qmf_outer_coeffs, 21,\n                                     intermediate_samples[0+i],\n                                     intermediate_samples[2+i],\n                                     &samples[2*i]);\n}", "static void aptx_decode_channel(struct aptx_channel *channel, int32_t samples[4])\n{\n    int32_t subband_samples[NB_SUBBANDS];\n    unsigned subband;\n\n    for (subband = 0; subband < NB_SUBBANDS; subband++)\n        subband_samples[subband] = channel->prediction[subband].previous_reconstructed_sample;\n    aptx_qmf_tree_synthesis(&channel->qmf, subband_samples, samples);\n}"], "Enums": []}