{"Includes": ["#include <stdint.h>\n", "#include <stdlib.h>\n", "#include <string.h>\n"], "Defines": ["#define DIFFSIGN(x,y) (((x)>(y)) - ((x)<(y)))\n"], "TypeDefs": [], "Globals": [], "Structs": ["struct aptx_prediction {\n    int32_t prev_sign[2];\n    int32_t s_weight[2];\n    int32_t d_weight[24];\n    int32_t pos;\n    int32_t reconstructed_differences[48];\n    int32_t previous_reconstructed_sample;\n    int32_t predicted_difference;\n    int32_t predicted_sample;\n};"], "Function Declarations": ["static inline int32_t clip_intp2(int32_t a, unsigned p)\n;", "static inline int32_t rshift32(int32_t value, unsigned shift) ;", "static int32_t *aptx_reconstructed_differences_update(struct aptx_prediction *prediction,\n                                                      int32_t reconstructed_difference,\n                                                      int order)\n;", "static void aptx_prediction_filtering(struct aptx_prediction *prediction,\n                                      int32_t reconstructed_difference,\n                                      int order)\n;"], "Function Implementations": ["static inline int32_t clip_intp2(int32_t a, unsigned p)\n{\n    if (((uint32_t)a + ((uint32_t)1 << p)) & ~(((uint32_t)2 << p) - 1))\n        return (a >> 31) ^ ((1 << p) - 1);\n    else\n        return a;\n}", "static inline int32_t rshift32(int32_t value, unsigned shift) { const int32_t rounding = (int32_t)1 << (shift - 1); const int32_t mask = ((int32_t)1 << (shift + 1)) - 1; return ((value + rounding) >> shift) - ((value & mask) == rounding); }", "static int32_t *aptx_reconstructed_differences_update(struct aptx_prediction *prediction,\n                                                      int32_t reconstructed_difference,\n                                                      int order)\n{\n    int32_t *rd1 = prediction->reconstructed_differences, *rd2 = rd1 + order;\n    int p = prediction->pos;\n\n    rd1[p] = rd2[p];\n    prediction->pos = p = (p + 1) % order;\n    rd2[p] = reconstructed_difference;\n    return &rd2[p];\n}", "static void aptx_prediction_filtering(struct aptx_prediction *prediction,\n                                      int32_t reconstructed_difference,\n                                      int order)\n{\n    int32_t reconstructed_sample, predictor, srd0, srd;\n    int32_t *reconstructed_differences;\n    int64_t predicted_difference = 0;\n    int i;\n\n    reconstructed_sample = clip_intp2(reconstructed_difference + prediction->predicted_sample, 23);\n    predictor = clip_intp2((int32_t)(((int64_t)prediction->s_weight[0] * (int64_t)prediction->previous_reconstructed_sample\n                                    + (int64_t)prediction->s_weight[1] * (int64_t)reconstructed_sample) >> 22), 23);\n    prediction->previous_reconstructed_sample = reconstructed_sample;\n\n    reconstructed_differences = aptx_reconstructed_differences_update(prediction, reconstructed_difference, order);\n    srd0 = (int32_t)DIFFSIGN(reconstructed_difference, 0) * ((int32_t)1 << 23);\n    for (i = 0; i < order; i++) {\n        srd = (reconstructed_differences[-i-1] >> 31) | 1;\n        prediction->d_weight[i] -= rshift32(prediction->d_weight[i] - srd*srd0, 8);\n        predicted_difference += (int64_t)reconstructed_differences[-i] * (int64_t)prediction->d_weight[i];\n    }\n\n    prediction->predicted_difference = clip_intp2((int32_t)(predicted_difference >> 22), 23);\n    prediction->predicted_sample = clip_intp2(predictor + prediction->predicted_difference, 23);\n}"], "Enums": []}