{"Includes": ["#include <stdio.h>\n", "#include <stdint.h>\n", "#include <stdlib.h> /* calloc() */\n", "#include <string.h> /* strdup() */\n"], "Defines": ["#define OPL_EMU_REGISTERS_OPERATORS ( OPL_EMU_REGISTERS_CHANNELS * 2 )\n", "#define OPL_EMU_REGISTERS_ALL_CHANNELS ( (1 << OPL_EMU_REGISTERS_CHANNELS) - 1 )\n", "#define OPL_EMU_REGISTERS_RHYTHM_CHANNEL 0xff\n", "#define OPL_EMU_REGISTERS_WAVEFORMS 8\n", "#define OPL_EMU_REGISTERS_CHANNELS 18\n", "#define OPL_EMU_REGISTERS_REGISTERS 0x200\n", "#define OPL_EMU_REGISTERS_REG_MODE 0x04\n", "#define OPL_EMU_REGISTERS_WAVEFORM_LENGTH 0x400\n"], "TypeDefs": ["typedef struct opl_t opl_t;"], "Globals": [], "Structs": ["struct opl_emu_registers\n{\n\t// internal state\n\tuint16_t m_lfo_am_counter;            // LFO AM counter\n\tuint16_t m_lfo_pm_counter;            // LFO PM counter\n\tuint32_t m_noise_lfsr;                // noise LFSR state\n\tuint8_t m_lfo_am;                     // current LFO AM value\n\tuint8_t m_regdata[OPL_EMU_REGISTERS_REGISTERS];         // register data\n\tuint16_t m_waveform[OPL_EMU_REGISTERS_WAVEFORMS][OPL_EMU_REGISTERS_WAVEFORM_LENGTH]; // waveforms\n};", "struct opl_emu_opdata_cache\n{\n\t// set phase_step to this value to recalculate it each sample; needed\n\t// in the case of PM LFO changes\n\n\tuint32_t phase_step;              // phase step, or OPL_EMU_PHASE_STEP_DYNAMIC if PM is active\n\tuint32_t total_level;             // total level * 8 + KSL\n\tuint32_t block_freq;              // raw block frequency value (used to compute phase_step)\n\tint32_t detune;                   // detuning value (used to compute phase_step)\n\tuint32_t multiple;                // multiple value (x.1, used to compute phase_step)\n\tuint32_t eg_sustain;              // sustain level, shifted up to envelope values\n\tuint8_t eg_rate[OPL_EMU_EG_STATES];       // envelope rate, including KSR\n\tuint8_t eg_shift;                 // envelope shift amount\n};", "struct opl_emu_fm_operator\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tuint32_t m_opoffs;                     // operator offset in registers\n\tuint32_t m_phase;                      // current phase value (10.10 format)\n\tuint16_t m_env_attenuation;            // computed envelope attenuation (4.6 format)\n\tenum opl_emu_envelope_state m_env_state;            // current envelope state\n\tuint8_t m_key_state;                   // current key state: on or off (bit 0)\n\tuint8_t m_keyon_live;                  // live key on state (bit 0 = direct, bit 1 = rhythm, bit 2 = CSM)\n\tstruct opl_emu_opdata_cache m_cache;                  // cached values for performance\n\tstruct opl_emu_registers* m_regs;                  // direct reference to registers\n};", "struct opl_emu_fm_channel\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tint16_t m_feedback[2];                 // feedback memory for operator 1\n\tint16_t m_feedback_in;         // next input value for op 1 feedback (set in output)\n\tstruct opl_emu_fm_operator *m_op[4];    // up to 4 operators\n\tstruct opl_emu_registers* m_regs;                  // direct reference to registers\n};", "typedef struct opl_timbre_t {\n  unsigned long modulator_E862, carrier_E862;\n  unsigned char modulator_40, carrier_40;\n  unsigned char feedconn;\n  signed char finetune;\n  unsigned char notenum;\n  signed short noteoffset;\n} opl_timbre_t;", "struct opl_emu_t\n{\n\tuint32_t m_env_counter;          // envelope counter; low 2 bits are sub-counter\n\tuint8_t m_status;                // current status register\n\tuint8_t m_timer_running[2];      // current timer running state\n\tuint32_t m_active_channels;      // mask of active channels (computed by prepare)\n\tuint32_t m_modified_channels;    // mask of channels that have been modified\n\tuint32_t m_prepare_count;        // counter to do periodic prepare sweeps\n\tstruct opl_emu_registers m_regs;             // register accessor\n\tstruct opl_emu_fm_channel m_channel[OPL_EMU_REGISTERS_CHANNELS]; // channel pointers\n\tstruct opl_emu_fm_operator m_operator[OPL_EMU_REGISTERS_OPERATORS]; // operator pointers\n};", "struct voicealloc_t {\n  unsigned short priority;\n  signed short timbreid;\n  signed char channel;\n  signed char note;\n  unsigned char voiceindex; /* 1 if 2nd voice for OP2 soundbank instrument, 0 otherwise */\n};", "struct opl_t {\n  signed char notes2voices[16][128][2]; /* keeps the map of channel:notes -> voice allocations */\n  unsigned short channelpitch[16];      /* per-channel pitch level */\n  unsigned short channelvol[16];        /* per-channel pitch level */\n  struct voicealloc_t voices2notes[18]; /* keeps the map of what voice is playing what note/channel currently */\n  unsigned char channelprog[16];        /* programs (patches) assigned to channels */\n  int opl3; /* flag indicating whether or not the sound module is OPL3-compatible or only OPL2 */\n  struct opl_emu_t opl_emu;\n  struct opl_timbre_t opl_gmtimbres[ 256 ];\n  struct opl_timbre_t opl_gmtimbres_voice2[ 256 ]; /* second voice included in OP2 format */\n  int is_op2; /* true if OP2 soundbank */\n  enum op2_flags_t op2_flags[ 256 ]; /* OP2 format flags */\n};"], "Function Declarations": ["uint32_t opl_emu_bitfield(uint32_t value, int start, int length )\n;", "void opl_emu_fm_operator_keyonoff(struct opl_emu_fm_operator* fmop, uint32_t on, enum opl_emu_keyon_type type)\n;", "void opl_emu_fm_channel_keyonoff(struct opl_emu_fm_channel* fmch,uint32_t states, enum opl_emu_keyon_type type, uint32_t chnum)\n;", "int opl_emu_registers_write(struct opl_emu_registers* regs,uint16_t index, uint8_t data, uint32_t *channel, uint32_t *opmask)\n;", "void opl_write( opl_t* opl, int count, unsigned short* regs, unsigned char* data ) ;"], "Function Implementations": ["uint32_t opl_emu_bitfield(uint32_t value, int start, int length )\n{\n\treturn (value >> start) & ((1 << length) - 1);\n}", "void opl_emu_fm_operator_keyonoff(struct opl_emu_fm_operator* fmop, uint32_t on, enum opl_emu_keyon_type type)\n{\n\tfmop->m_keyon_live = (fmop->m_keyon_live & ~(1 << (int)(type))) | (opl_emu_bitfield(on, 0,1) << (int)(type));\n}", "void opl_emu_fm_channel_keyonoff(struct opl_emu_fm_channel* fmch,uint32_t states, enum opl_emu_keyon_type type, uint32_t chnum)\n{\n\tfor (uint32_t opnum = 0; opnum < sizeof( fmch->m_op ) / sizeof( *fmch->m_op ); opnum++)\n\t\tif (fmch->m_op[opnum] != NULL)\n\t\t\topl_emu_fm_operator_keyonoff(fmch->m_op[opnum],opl_emu_bitfield(states, opnum,1), type);\n}", "int opl_emu_registers_write(struct opl_emu_registers* regs,uint16_t index, uint8_t data, uint32_t *channel, uint32_t *opmask)\n{\n\t// writes to the mode register with high bit set ignore the low bits\n\tif (index == OPL_EMU_REGISTERS_REG_MODE && opl_emu_bitfield(data, 7,1) != 0)\n\t\tregs->m_regdata[index] |= 0x80;\n\telse\n\t\tregs->m_regdata[index] = data;\n\n\t// handle writes to the rhythm keyons\n\tif (index == 0xbd)\n\t{\n\t\t*channel = OPL_EMU_REGISTERS_RHYTHM_CHANNEL;\n\t\t*opmask = opl_emu_bitfield(data, 5,1) ? opl_emu_bitfield(data, 0, 5) : 0;\n\t\treturn 1;\n\t}\n\n\t// handle writes to the channel keyons\n\tif ((index & 0xf0) == 0xb0)\n\t{\n\t\t*channel = index & 0x0f;\n\t\tif (*channel < 9)\n\t\t{\n            *channel += 9 * opl_emu_bitfield(index, 8,1);\n\t\t\t*opmask = opl_emu_bitfield(data, 5,1) ? 15 : 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}", "void opl_write( opl_t* opl, int count, unsigned short* regs, unsigned char* data ) {\n    struct opl_emu_t* emu = &opl->opl_emu;\n    for( int i = 0; i < count; ++i ) {\n        uint16_t regnum = regs[ i ];\n        uint8_t value = data[ i ];\n\t    // special case: writes to the mode register can impact IRQs;\n\t    // schedule these writes to ensure ordering with timers\n\t    if (regnum == OPL_EMU_REGISTERS_REG_MODE)\n\t    {\n    //\t\temu->m_intf.opl_emu_sync_mode_write(data);\n\t\t    continue;;\n\t    }\n\n\t    // for now just mark all channels as modified\n\t    emu->m_modified_channels = OPL_EMU_REGISTERS_ALL_CHANNELS;\n\n\t    // most writes are passive, consumed only when needed\n\t    uint32_t keyon_channel;\n\t    uint32_t keyon_opmask;\n\t    if (opl_emu_registers_write(&emu->m_regs,regnum, value, &keyon_channel, &keyon_opmask))\n\t    {\n\t\t    // handle writes to the keyon register(s)\n\t\t    if (keyon_channel < OPL_EMU_REGISTERS_CHANNELS)\n\t\t    {\n\t\t\t    // normal channel on/off\n\t\t\t    opl_emu_fm_channel_keyonoff(&emu->m_channel[keyon_channel],keyon_opmask, OPL_EMU_KEYON_NORMAL, keyon_channel);\n\t\t    }\n\t\t    else if (OPL_EMU_REGISTERS_CHANNELS >= 9 && keyon_channel == OPL_EMU_REGISTERS_RHYTHM_CHANNEL)\n\t\t    {\n\t\t\t    // special case for the OPL rhythm channels\n\t\t\t    opl_emu_fm_channel_keyonoff(&emu->m_channel[6],opl_emu_bitfield(keyon_opmask, 4,1) ? 3 : 0, OPL_EMU_KEYON_RHYTHM, 6);\n\t\t\t    opl_emu_fm_channel_keyonoff(&emu->m_channel[7],opl_emu_bitfield(keyon_opmask, 0,1) | (opl_emu_bitfield(keyon_opmask, 3,1) << 1), OPL_EMU_KEYON_RHYTHM, 7);\n\t\t\t    opl_emu_fm_channel_keyonoff(&emu->m_channel[8],opl_emu_bitfield(keyon_opmask, 2,1) | (opl_emu_bitfield(keyon_opmask, 1,1) << 1), OPL_EMU_KEYON_RHYTHM, 8);\n\t\t    }\n\t    }\n    }\n}"], "Enums": ["enum opl_emu_envelope_state\n{\n\tOPL_EMU_EG_ATTACK = 1,\n\tOPL_EMU_EG_DECAY = 2,\n\tOPL_EMU_EG_SUSTAIN = 3,\n\tOPL_EMU_EG_RELEASE = 4,\n\tOPL_EMU_EG_STATES = 6\n};", "enum opl_emu_keyon_type\n{\n\tOPL_EMU_KEYON_NORMAL = 0,\n\tOPL_EMU_KEYON_RHYTHM = 1,\n\tOPL_EMU_KEYON_CSM = 2\n};", "enum op2_flags_t {\n  OP2_FIXEDPITCH = 1,\n  OP2_UNUSED = 2, /* technically delayed vibrato https://moddingwiki.shikadi.net/wiki/OP2_Bank_Format */\n  OP2_DOUBLEVOICE = 4,\n};"]}