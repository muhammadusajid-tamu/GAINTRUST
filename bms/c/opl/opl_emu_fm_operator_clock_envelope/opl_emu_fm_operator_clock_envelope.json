{"Includes": ["#include <stdio.h>\n", "#include <stdint.h>\n", "#include <stdlib.h> /* calloc() */\n", "#include <string.h> /* strdup() */\n"], "Defines": ["#define OPL_EMU_REGISTERS_WAVEFORMS 8\n", "#define OPL_EMU_REGISTERS_REGISTERS 0x200\n", "#define OPL_EMU_REGISTERS_WAVEFORM_LENGTH 0x400\n"], "TypeDefs": [], "Globals": [], "Structs": ["struct opl_emu_registers\n{\n\t// internal state\n\tuint16_t m_lfo_am_counter;            // LFO AM counter\n\tuint16_t m_lfo_pm_counter;            // LFO PM counter\n\tuint32_t m_noise_lfsr;                // noise LFSR state\n\tuint8_t m_lfo_am;                     // current LFO AM value\n\tuint8_t m_regdata[OPL_EMU_REGISTERS_REGISTERS];         // register data\n\tuint16_t m_waveform[OPL_EMU_REGISTERS_WAVEFORMS][OPL_EMU_REGISTERS_WAVEFORM_LENGTH]; // waveforms\n};", "struct opl_emu_opdata_cache\n{\n\t// set phase_step to this value to recalculate it each sample; needed\n\t// in the case of PM LFO changes\n\n\tuint32_t phase_step;              // phase step, or OPL_EMU_PHASE_STEP_DYNAMIC if PM is active\n\tuint32_t total_level;             // total level * 8 + KSL\n\tuint32_t block_freq;              // raw block frequency value (used to compute phase_step)\n\tint32_t detune;                   // detuning value (used to compute phase_step)\n\tuint32_t multiple;                // multiple value (x.1, used to compute phase_step)\n\tuint32_t eg_sustain;              // sustain level, shifted up to envelope values\n\tuint8_t eg_rate[OPL_EMU_EG_STATES];       // envelope rate, including KSR\n\tuint8_t eg_shift;                 // envelope shift amount\n};", "struct opl_emu_fm_operator\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tuint32_t m_opoffs;                     // operator offset in registers\n\tuint32_t m_phase;                      // current phase value (10.10 format)\n\tuint16_t m_env_attenuation;            // computed envelope attenuation (4.6 format)\n\tenum opl_emu_envelope_state m_env_state;            // current envelope state\n\tuint8_t m_key_state;                   // current key state: on or off (bit 0)\n\tuint8_t m_keyon_live;                  // live key on state (bit 0 = direct, bit 1 = rhythm, bit 2 = CSM)\n\tstruct opl_emu_opdata_cache m_cache;                  // cached values for performance\n\tstruct opl_emu_registers* m_regs;                  // direct reference to registers\n};"], "Function Declarations": ["uint32_t opl_emu_bitfield(uint32_t value, int start, int length )\n;", "uint32_t opl_emu_attenuation_increment(uint32_t rate, uint32_t index)\n;", "void opl_emu_fm_operator_clock_envelope(struct opl_emu_fm_operator* fmop, uint32_t env_counter)\n;"], "Function Implementations": ["uint32_t opl_emu_bitfield(uint32_t value, int start, int length )\n{\n\treturn (value >> start) & ((1 << length) - 1);\n}", "uint32_t opl_emu_attenuation_increment(uint32_t rate, uint32_t index)\n{\n\tstatic uint32_t const s_increment_table[64] =\n\t{\n\t\t0x00000000, 0x00000000, 0x10101010, 0x10101010,  // 0-3    (0x00-0x03)\n\t\t0x10101010, 0x10101010, 0x11101110, 0x11101110,  // 4-7    (0x04-0x07)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 8-11   (0x08-0x0B)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 12-15  (0x0C-0x0F)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 16-19  (0x10-0x13)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 20-23  (0x14-0x17)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 24-27  (0x18-0x1B)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 28-31  (0x1C-0x1F)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 32-35  (0x20-0x23)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 36-39  (0x24-0x27)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 40-43  (0x28-0x2B)\n\t\t0x10101010, 0x10111010, 0x11101110, 0x11111110,  // 44-47  (0x2C-0x2F)\n\t\t0x11111111, 0x21112111, 0x21212121, 0x22212221,  // 48-51  (0x30-0x33)\n\t\t0x22222222, 0x42224222, 0x42424242, 0x44424442,  // 52-55  (0x34-0x37)\n\t\t0x44444444, 0x84448444, 0x84848484, 0x88848884,  // 56-59  (0x38-0x3B)\n\t\t0x88888888, 0x88888888, 0x88888888, 0x88888888   // 60-63  (0x3C-0x3F)\n\t};\n\treturn opl_emu_bitfield(s_increment_table[rate], 4*index, 4);\n}", "void opl_emu_fm_operator_clock_envelope(struct opl_emu_fm_operator* fmop, uint32_t env_counter)\n{\n\t// handle attack->decay transitions\n\tif (fmop->m_env_state == OPL_EMU_EG_ATTACK && fmop->m_env_attenuation == 0)\n\t\tfmop->m_env_state = OPL_EMU_EG_DECAY;\n\n\t// handle decay->sustain transitions; it is important to do this immediately\n\t// after the attack->decay transition above in the event that the sustain level\n\t// is set to 0 (in which case we will skip right to sustain without doing any\n\t// decay); as an example where this can be heard, check the cymbals sound\n\t// in channel 0 of shinobi's test mode sound #5\n\tif (fmop->m_env_state == OPL_EMU_EG_DECAY && fmop->m_env_attenuation >= fmop->m_cache.eg_sustain)\n\t\tfmop->m_env_state = OPL_EMU_EG_SUSTAIN;\n\n\t// fetch the appropriate 6-bit rate value from the cache\n\tuint32_t rate = fmop->m_cache.eg_rate[fmop->m_env_state];\n\n\t// compute the rate shift value; this is the shift needed to\n\t// apply to the env_counter such that it becomes a 5.11 fixed\n\t// point number\n\tuint32_t rate_shift = rate >> 2;\n\tenv_counter <<= rate_shift;\n\n\t// see if the fractional part is 0; if not, it's not time to clock\n\tif (opl_emu_bitfield(env_counter, 0, 11) != 0)\n\t\treturn;\n\n\t// determine the increment based on the non-fractional part of env_counter\n\tuint32_t relevant_bits = opl_emu_bitfield(env_counter, (rate_shift <= 11) ? 11 : rate_shift, 3);\n\tuint32_t increment = opl_emu_attenuation_increment(rate, relevant_bits);\n\n\t// attack is the only one that increases\n\tif (fmop->m_env_state == OPL_EMU_EG_ATTACK)\n\t{\n\t\t// glitch means that attack rates of 62/63 don't increment if\n\t\t// changed after the initial key on (where they are handled\n\t\t// specially); nukeykt confirms this happens on OPM, OPN, OPL/OPLL\n\t\t// at least so assuming it is true for everyone\n\t\tif (rate < 62)\n\t\t\tfmop->m_env_attenuation += (~fmop->m_env_attenuation * increment) >> 4;\n\t}\n\n\t// all other cases are similar\n\telse\n\t{\n\t\t// non-SSG-EG cases just apply the increment\n        fmop->m_env_attenuation += increment;\n\n\t\t// clamp the final attenuation\n\t\tif (fmop->m_env_attenuation >= 0x400)\n\t\t\tfmop->m_env_attenuation = 0x3ff;\n\t}\n}"], "Enums": ["enum opl_emu_envelope_state\n{\n\tOPL_EMU_EG_ATTACK = 1,\n\tOPL_EMU_EG_DECAY = 2,\n\tOPL_EMU_EG_SUSTAIN = 3,\n\tOPL_EMU_EG_RELEASE = 4,\n\tOPL_EMU_EG_STATES = 6\n};"]}