{"Includes": ["#include <stdio.h>\n", "#include <stdint.h>\n", "#include <stdlib.h> /* calloc() */\n", "#include <string.h> /* strdup() */\n"], "Defines": ["#define OPL_EMU_REGISTERS_OPERATORS ( OPL_EMU_REGISTERS_CHANNELS * 2 )\n", "#define OPL_EMU_REGISTERS_WAVEFORMS 8\n", "#define OPL_EMU_REGISTERS_CHANNELS 18\n", "#define OPL_EMU_REGISTERS_REGISTERS 0x200\n", "#define OPL_EMU_REGISTERS_WAVEFORM_LENGTH 0x400\n"], "TypeDefs": ["typedef struct opl_t opl_t;"], "Globals": [], "Structs": ["struct opl_emu_registers\n{\n\t// internal state\n\tuint16_t m_lfo_am_counter;            // LFO AM counter\n\tuint16_t m_lfo_pm_counter;            // LFO PM counter\n\tuint32_t m_noise_lfsr;                // noise LFSR state\n\tuint8_t m_lfo_am;                     // current LFO AM value\n\tuint8_t m_regdata[OPL_EMU_REGISTERS_REGISTERS];         // register data\n\tuint16_t m_waveform[OPL_EMU_REGISTERS_WAVEFORMS][OPL_EMU_REGISTERS_WAVEFORM_LENGTH]; // waveforms\n};", "struct opl_emu_opdata_cache\n{\n\t// set phase_step to this value to recalculate it each sample; needed\n\t// in the case of PM LFO changes\n\n\tuint32_t phase_step;              // phase step, or OPL_EMU_PHASE_STEP_DYNAMIC if PM is active\n\tuint32_t total_level;             // total level * 8 + KSL\n\tuint32_t block_freq;              // raw block frequency value (used to compute phase_step)\n\tint32_t detune;                   // detuning value (used to compute phase_step)\n\tuint32_t multiple;                // multiple value (x.1, used to compute phase_step)\n\tuint32_t eg_sustain;              // sustain level, shifted up to envelope values\n\tuint8_t eg_rate[OPL_EMU_EG_STATES];       // envelope rate, including KSR\n\tuint8_t eg_shift;                 // envelope shift amount\n};", "struct opl_emu_fm_operator\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tuint32_t m_opoffs;                     // operator offset in registers\n\tuint32_t m_phase;                      // current phase value (10.10 format)\n\tuint16_t m_env_attenuation;            // computed envelope attenuation (4.6 format)\n\tenum opl_emu_envelope_state m_env_state;            // current envelope state\n\tuint8_t m_key_state;                   // current key state: on or off (bit 0)\n\tuint8_t m_keyon_live;                  // live key on state (bit 0 = direct, bit 1 = rhythm, bit 2 = CSM)\n\tstruct opl_emu_opdata_cache m_cache;                  // cached values for performance\n};", "struct opl_emu_fm_channel\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tint16_t m_feedback[2];                 // feedback memory for operator 1\n\tint16_t m_feedback_in;         // next input value for op 1 feedback (set in output)\n};", "typedef struct opl_timbre_t {\n  unsigned long modulator_E862, carrier_E862;\n  unsigned char modulator_40, carrier_40;\n  unsigned char feedconn;\n  signed char finetune;\n  unsigned char notenum;\n  signed short noteoffset;\n} opl_timbre_t;", "struct opl_emu_t\n{\n\tuint32_t m_env_counter;          // envelope counter; low 2 bits are sub-counter\n\tuint8_t m_status;                // current status register\n\tuint8_t m_timer_running[2];      // current timer running state\n\tuint32_t m_active_channels;      // mask of active channels (computed by prepare)\n\tuint32_t m_modified_channels;    // mask of channels that have been modified\n\tuint32_t m_prepare_count;        // counter to do periodic prepare sweeps\n\tstruct opl_emu_registers m_regs;             // register accessor\n\tstruct opl_emu_fm_channel m_channel[OPL_EMU_REGISTERS_CHANNELS]; // channel pointers\n\tstruct opl_emu_fm_operator m_operator[OPL_EMU_REGISTERS_OPERATORS]; // operator pointers\n};", "struct voicealloc_t {\n  unsigned short priority;\n  signed short timbreid;\n  signed char channel;\n  signed char note;\n  unsigned char voiceindex; /* 1 if 2nd voice for OP2 soundbank instrument, 0 otherwise */\n};", "struct opl_t {\n  signed char notes2voices[16][128][2]; /* keeps the map of channel:notes -> voice allocations */\n  unsigned short channelpitch[16];      /* per-channel pitch level */\n  unsigned short channelvol[16];        /* per-channel pitch level */\n  struct voicealloc_t voices2notes[18]; /* keeps the map of what voice is playing what note/channel currently */\n  unsigned char channelprog[16];        /* programs (patches) assigned to channels */\n  int opl3; /* flag indicating whether or not the sound module is OPL3-compatible or only OPL2 */\n  struct opl_emu_t opl_emu;\n  struct opl_timbre_t opl_gmtimbres[ 256 ];\n  struct opl_timbre_t opl_gmtimbres_voice2[ 256 ]; /* second voice included in OP2 format */\n  int is_op2; /* true if OP2 soundbank */\n  enum op2_flags_t op2_flags[ 256 ]; /* OP2 format flags */\n};"], "Function Declarations": ["static int opl_loadbank_internal(opl_t* opl, char const* file, int offset) ;", "int opl_loadbank_ibk(opl_t* opl, char const* file) ;"], "Function Implementations": ["static int opl_loadbank_internal(opl_t* opl, char const* file, int offset) {\n  opl->is_op2 = 0;\n  unsigned char buff[16];\n  int i;\n  /* open the IBK file */\n  FILE* f = fopen( file, \"rb\" );\n  if( !f ) return -1;\n  /* file must be exactly 3204 bytes long */\n  fseek( f, 0, SEEK_END );\n  if (ftell(f) != 3204) {\n    fclose(f);\n    return(-2);\n  }\n  fseek( f, 0, SEEK_SET);\n  /* file must start with an IBK header */\n  if ((fread(buff, 1, 4,f) != 4) || (buff[0] != 'I') || (buff[1] != 'B') || (buff[2] != 'K') || (buff[3] != 0x1A)) {\n    fclose(f);\n    return(-3);\n  }\n  /* load 128 instruments from the IBK file */\n  for (i = offset; i < 128 + offset; i++) {\n    /* load instruments */\n    if (fread(buff, 1, 16, f) != 16) {\n      fclose(f);\n      return(-4);\n    }\n    /* load modulator */\n    opl->opl_gmtimbres[i].modulator_E862 = buff[8]; /* wave select */\n    opl->opl_gmtimbres[i].modulator_E862 <<= 8;\n    opl->opl_gmtimbres[i].modulator_E862 |= buff[6]; /* sust/release */\n    opl->opl_gmtimbres[i].modulator_E862 <<= 8;\n    opl->opl_gmtimbres[i].modulator_E862 |= buff[4]; /* attack/decay */\n    opl->opl_gmtimbres[i].modulator_E862 <<= 8;\n    opl->opl_gmtimbres[i].modulator_E862 |= buff[0]; /* AM/VIB... flags */\n    /* load carrier */\n    opl->opl_gmtimbres[i].carrier_E862 = buff[9]; /* wave select */\n    opl->opl_gmtimbres[i].carrier_E862 <<= 8;\n    opl->opl_gmtimbres[i].carrier_E862 |= buff[7]; /* sust/release */\n    opl->opl_gmtimbres[i].carrier_E862 <<= 8;\n    opl->opl_gmtimbres[i].carrier_E862 |= buff[5]; /* attack/decay */\n    opl->opl_gmtimbres[i].carrier_E862 <<= 8;\n    opl->opl_gmtimbres[i].carrier_E862 |= buff[1]; /* AM/VIB... flags */\n    /* load KSL */\n    opl->opl_gmtimbres[i].modulator_40 = buff[2];\n    opl->opl_gmtimbres[i].carrier_40 = buff[3];\n    /* feedconn & finetune */\n    opl->opl_gmtimbres[i].feedconn = buff[10];\n    opl->opl_gmtimbres[i].finetune = buff[12]; /* used only in some IBK files */\n    opl->opl_gmtimbres[i].notenum = 60;\n    opl->opl_gmtimbres[i].noteoffset = 0;\n  }\n  /* close file and return success */\n  fclose(f);\n  return(0);\n}", "int opl_loadbank_ibk(opl_t* opl, char const* file) {\n  char *instruments = NULL, *percussion = NULL;\n  int i, res;\n  instruments = strdup(file); /* duplicate the string so we can modify it */\n  if (instruments == NULL) return(-64); /* out of mem */\n  /* if a second file is provided, it's for percussion */\n  for (i = 0; instruments[i] != 0; i++) {\n    if (instruments[i] == ',') {\n      instruments[i] = 0;\n      percussion = instruments + i + 1;\n      break;\n    }\n  }\n  /* load the file(s) */\n  res = opl_loadbank_internal(opl, instruments, 0);\n  if ((res == 0) && (percussion != NULL)) {\n    res = opl_loadbank_internal(opl, percussion, 128);\n  }\n  free(instruments);\n  /*dump2file();*/ /* dump instruments to a 'dump.txt' file */\n  return(res);\n}"], "Enums": ["enum opl_emu_envelope_state\n{\n\tOPL_EMU_EG_ATTACK = 1,\n\tOPL_EMU_EG_DECAY = 2,\n\tOPL_EMU_EG_SUSTAIN = 3,\n\tOPL_EMU_EG_RELEASE = 4,\n\tOPL_EMU_EG_STATES = 6\n};", "enum op2_flags_t {\n  OP2_FIXEDPITCH = 1,\n  OP2_UNUSED = 2, /* technically delayed vibrato https://moddingwiki.shikadi.net/wiki/OP2_Bank_Format */\n  OP2_DOUBLEVOICE = 4,\n};"]}