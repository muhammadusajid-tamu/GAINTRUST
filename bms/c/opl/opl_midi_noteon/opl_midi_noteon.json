{"Includes": ["#include <stdio.h>\n", "#include <stdint.h>\n", "#include <stdlib.h> /* calloc() */\n", "#include <string.h> /* strdup() */\n"], "Defines": ["#define OPL_EMU_REGISTERS_ALL_CHANNELS ( (1 << OPL_EMU_REGISTERS_CHANNELS) - 1 )\n", "#define OPL_EMU_REGISTERS_RHYTHM_CHANNEL 0xff\n", "#define OPL_EMU_REGISTERS_WAVEFORMS 8\n", "#define OPL_EMU_REGISTERS_WAVEFORM_LENGTH 0x400\n", "#define OPL_EMU_REGISTERS_CHANNELS 18\n", "#define OPL_EMU_REGISTERS_REGISTERS 0x200\n", "#define OPL_EMU_REGISTERS_REG_MODE 0x04\n", "#define OPL_EMU_REGISTERS_OPERATORS ( OPL_EMU_REGISTERS_CHANNELS * 2 )\n", "#define OP2_2NDVOICE_PRIORITY_PENALTY 0xFF\n"], "TypeDefs": ["typedef struct opl_t opl_t;"], "Globals": ["const unsigned short op2offsets[18] = {0x03,0x04,0x05,0x0b,0x0c,0x0d,0x13,0x14,0x15,0x103,0x104,0x105,0x10b,0x10c,0x10d,0x113,0x114,0x115};", "const unsigned short freqtable[128] = {                          /* note # */\n        345, 365, 387, 410, 435, 460, 488, 517, 547, 580, 615, 651,  /*  0 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 12 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 24 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 36 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 48 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 60 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 72 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 84 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651,  /* 96 */\n        690, 731, 774, 820, 869, 921, 975, 517, 547, 580, 615, 651, /* 108 */\n        690, 731, 774, 820, 869, 921, 975, 517};", "const unsigned short pitchtable[256] = {                    /* pitch wheel */\n         29193U,29219U,29246U,29272U,29299U,29325U,29351U,29378U,  /* -128 */\n         29405U,29431U,29458U,29484U,29511U,29538U,29564U,29591U,  /* -120 */\n         29618U,29644U,29671U,29698U,29725U,29752U,29778U,29805U,  /* -112 */\n         29832U,29859U,29886U,29913U,29940U,29967U,29994U,30021U,  /* -104 */\n         30048U,30076U,30103U,30130U,30157U,30184U,30212U,30239U,  /*  -96 */\n         30266U,30293U,30321U,30348U,30376U,30403U,30430U,30458U,  /*  -88 */\n         30485U,30513U,30541U,30568U,30596U,30623U,30651U,30679U,  /*  -80 */\n         30706U,30734U,30762U,30790U,30817U,30845U,30873U,30901U,  /*  -72 */\n         30929U,30957U,30985U,31013U,31041U,31069U,31097U,31125U,  /*  -64 */\n         31153U,31181U,31209U,31237U,31266U,31294U,31322U,31350U,  /*  -56 */\n         31379U,31407U,31435U,31464U,31492U,31521U,31549U,31578U,  /*  -48 */\n         31606U,31635U,31663U,31692U,31720U,31749U,31778U,31806U,  /*  -40 */\n         31835U,31864U,31893U,31921U,31950U,31979U,32008U,32037U,  /*  -32 */\n         32066U,32095U,32124U,32153U,32182U,32211U,32240U,32269U,  /*  -24 */\n         32298U,32327U,32357U,32386U,32415U,32444U,32474U,32503U,  /*  -16 */\n         32532U,32562U,32591U,32620U,32650U,32679U,32709U,32738U,  /*   -8 */\n         32768U,32798U,32827U,32857U,32887U,32916U,32946U,32976U,  /*    0 */\n         33005U,33035U,33065U,33095U,33125U,33155U,33185U,33215U,  /*    8 */\n         33245U,33275U,33305U,33335U,33365U,33395U,33425U,33455U,  /*   16 */\n         33486U,33516U,33546U,33576U,33607U,33637U,33667U,33698U,  /*   24 */\n         33728U,33759U,33789U,33820U,33850U,33881U,33911U,33942U,  /*   32 */\n         33973U,34003U,34034U,34065U,34095U,34126U,34157U,34188U,  /*   40 */\n         34219U,34250U,34281U,34312U,34343U,34374U,34405U,34436U,  /*   48 */\n         34467U,34498U,34529U,34560U,34591U,34623U,34654U,34685U,  /*   56 */\n         34716U,34748U,34779U,34811U,34842U,34874U,34905U,34937U,  /*   64 */\n         34968U,35000U,35031U,35063U,35095U,35126U,35158U,35190U,  /*   72 */\n         35221U,35253U,35285U,35317U,35349U,35381U,35413U,35445U,  /*   80 */\n         35477U,35509U,35541U,35573U,35605U,35637U,35669U,35702U,  /*   88 */\n         35734U,35766U,35798U,35831U,35863U,35895U,35928U,35960U,  /*   96 */\n         35993U,36025U,36058U,36090U,36123U,36155U,36188U,36221U,  /*  104 */\n         36254U,36286U,36319U,36352U,36385U,36417U,36450U,36483U,  /*  112 */\n         36516U,36549U,36582U,36615U,36648U,36681U,36715U,36748U};", "static int voicescount = 9;", "const unsigned short op1offsets[18] = {0x00,0x01,0x02,0x08,0x09,0x0a,0x10,0x11,0x12,0x100,0x101,0x102,0x108,0x109,0x10a,0x110,0x111,0x112};", "const unsigned char octavetable[128] = {                         /* note # */\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,                          /*  0 */\n        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,                          /* 12 */\n        1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2,                          /* 24 */\n        2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,                          /* 36 */\n        3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4,                          /* 48 */\n        4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5,                          /* 60 */\n        5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,                          /* 72 */\n        6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7,                          /* 84 */\n        7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8,                          /* 96 */\n        8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,                         /* 108 */\n        9, 9, 9, 9, 9, 9, 9,10};"], "Structs": ["struct opl_emu_registers\n{\n\t// internal state\n\tuint16_t m_lfo_am_counter;            // LFO AM counter\n\tuint16_t m_lfo_pm_counter;            // LFO PM counter\n\tuint32_t m_noise_lfsr;                // noise LFSR state\n\tuint8_t m_lfo_am;                     // current LFO AM value\n\tuint8_t m_regdata[OPL_EMU_REGISTERS_REGISTERS];         // register data\n\tuint16_t m_waveform[OPL_EMU_REGISTERS_WAVEFORMS][OPL_EMU_REGISTERS_WAVEFORM_LENGTH]; // waveforms\n};", "struct opl_emu_opdata_cache\n{\n\t// set phase_step to this value to recalculate it each sample; needed\n\t// in the case of PM LFO changes\n\n\tuint32_t phase_step;              // phase step, or OPL_EMU_PHASE_STEP_DYNAMIC if PM is active\n\tuint32_t total_level;             // total level * 8 + KSL\n\tuint32_t block_freq;              // raw block frequency value (used to compute phase_step)\n\tint32_t detune;                   // detuning value (used to compute phase_step)\n\tuint32_t multiple;                // multiple value (x.1, used to compute phase_step)\n\tuint32_t eg_sustain;              // sustain level, shifted up to envelope values\n\tuint8_t eg_rate[OPL_EMU_EG_STATES];       // envelope rate, including KSR\n\tuint8_t eg_shift;                 // envelope shift amount\n};", "struct opl_emu_fm_operator\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tuint32_t m_opoffs;                     // operator offset in registers\n\tuint32_t m_phase;                      // current phase value (10.10 format)\n\tuint16_t m_env_attenuation;            // computed envelope attenuation (4.6 format)\n\tenum opl_emu_envelope_state m_env_state;            // current envelope state\n\tuint8_t m_key_state;                   // current key state: on or off (bit 0)\n\tuint8_t m_keyon_live;                  // live key on state (bit 0 = direct, bit 1 = rhythm, bit 2 = CSM)\n\tstruct opl_emu_opdata_cache m_cache;                  // cached values for performance\n\tstruct opl_emu_registers* m_regs;                  // direct reference to registers\n};", "struct opl_emu_fm_channel\n{\n\t// internal state\n\tuint32_t m_choffs;                     // channel offset in registers\n\tint16_t m_feedback[2];                 // feedback memory for operator 1\n\tint16_t m_feedback_in;         // next input value for op 1 feedback (set in output)\n\tstruct opl_emu_fm_operator *m_op[4];    // up to 4 operators\n\tstruct opl_emu_registers* m_regs;                  // direct reference to registers\n};", "typedef struct opl_timbre_t {\n  unsigned long modulator_E862, carrier_E862;\n  unsigned char modulator_40, carrier_40;\n  unsigned char feedconn;\n  signed char finetune;\n  unsigned char notenum;\n  signed short noteoffset;\n} opl_timbre_t;", "struct opl_emu_t\n{\n\tuint32_t m_env_counter;          // envelope counter; low 2 bits are sub-counter\n\tuint8_t m_status;                // current status register\n\tuint8_t m_timer_running[2];      // current timer running state\n\tuint32_t m_active_channels;      // mask of active channels (computed by prepare)\n\tuint32_t m_modified_channels;    // mask of channels that have been modified\n\tuint32_t m_prepare_count;        // counter to do periodic prepare sweeps\n\tstruct opl_emu_registers m_regs;             // register accessor\n\tstruct opl_emu_fm_channel m_channel[OPL_EMU_REGISTERS_CHANNELS]; // channel pointers\n\tstruct opl_emu_fm_operator m_operator[OPL_EMU_REGISTERS_OPERATORS]; // operator pointers\n};", "struct voicealloc_t {\n  unsigned short priority;\n  signed short timbreid;\n  signed char channel;\n  signed char note;\n  unsigned char voiceindex; /* 1 if 2nd voice for OP2 soundbank instrument, 0 otherwise */\n};", "struct opl_t {\n  signed char notes2voices[16][128][2]; /* keeps the map of channel:notes -> voice allocations */\n  unsigned short channelpitch[16];      /* per-channel pitch level */\n  unsigned short channelvol[16];        /* per-channel pitch level */\n  struct voicealloc_t voices2notes[18]; /* keeps the map of what voice is playing what note/channel currently */\n  unsigned char channelprog[16];        /* programs (patches) assigned to channels */\n  int opl3; /* flag indicating whether or not the sound module is OPL3-compatible or only OPL2 */\n  struct opl_emu_t opl_emu;\n  struct opl_timbre_t opl_gmtimbres[ 256 ];\n  struct opl_timbre_t opl_gmtimbres_voice2[ 256 ]; /* second voice included in OP2 format */\n  int is_op2; /* true if OP2 soundbank */\n  enum op2_flags_t op2_flags[ 256 ]; /* OP2 format flags */\n};"], "Function Declarations": ["uint32_t opl_emu_bitfield(uint32_t value, int start, int length )\n;", "void opl_emu_fm_operator_keyonoff(struct opl_emu_fm_operator* fmop, uint32_t on, enum opl_emu_keyon_type type)\n;", "void opl_emu_fm_channel_keyonoff(struct opl_emu_fm_channel* fmch,uint32_t states, enum opl_emu_keyon_type type, uint32_t chnum)\n;", "int opl_emu_registers_write(struct opl_emu_registers* regs,uint16_t index, uint8_t data, uint32_t *channel, uint32_t *opmask)\n;", "void opl_emu_write( struct opl_emu_t* emu, uint16_t regnum, uint8_t data)\n;", "void oplregwr( opl_t* opl, uint16_t reg, uint8_t data ) ;", "static void calc_vol(unsigned char *regbyte, int volume) ;", "void opl_noteoff(opl_t* opl, unsigned short voice) ;", "void opl_noteon(opl_t* opl, unsigned short voice, unsigned int note, int pitch) ;", "static void voicevolume(opl_t* opl, unsigned short voice, const opl_timbre_t* timbre, int volume) ;", "void opl_loadinstrument(opl_t* opl, int voice, opl_timbre_t *timbre) ;", "static int getinstrument(opl_t* opl, int channel, int note) ;", "void opl_midi_noteoff_op2(opl_t* opl, int channel, int note, int vindex) ;", "void opl_midi_noteon_op2(opl_t* opl, int channel, int note, int velocity, int vindex) ;", "void opl_midi_noteon(opl_t* opl, int channel, int note, int velocity) ;"], "Function Implementations": ["uint32_t opl_emu_bitfield(uint32_t value, int start, int length )\n{\n\treturn (value >> start) & ((1 << length) - 1);\n}", "void opl_emu_fm_operator_keyonoff(struct opl_emu_fm_operator* fmop, uint32_t on, enum opl_emu_keyon_type type)\n{\n\tfmop->m_keyon_live = (fmop->m_keyon_live & ~(1 << (int)(type))) | (opl_emu_bitfield(on, 0,1) << (int)(type));\n}", "void opl_emu_fm_channel_keyonoff(struct opl_emu_fm_channel* fmch,uint32_t states, enum opl_emu_keyon_type type, uint32_t chnum)\n{\n\tfor (uint32_t opnum = 0; opnum < sizeof( fmch->m_op ) / sizeof( *fmch->m_op ); opnum++)\n\t\tif (fmch->m_op[opnum] != NULL)\n\t\t\topl_emu_fm_operator_keyonoff(fmch->m_op[opnum],opl_emu_bitfield(states, opnum,1), type);\n}", "int opl_emu_registers_write(struct opl_emu_registers* regs,uint16_t index, uint8_t data, uint32_t *channel, uint32_t *opmask)\n{\n\t// writes to the mode register with high bit set ignore the low bits\n\tif (index == OPL_EMU_REGISTERS_REG_MODE && opl_emu_bitfield(data, 7,1) != 0)\n\t\tregs->m_regdata[index] |= 0x80;\n\telse\n\t\tregs->m_regdata[index] = data;\n\n\t// handle writes to the rhythm keyons\n\tif (index == 0xbd)\n\t{\n\t\t*channel = OPL_EMU_REGISTERS_RHYTHM_CHANNEL;\n\t\t*opmask = opl_emu_bitfield(data, 5,1) ? opl_emu_bitfield(data, 0, 5) : 0;\n\t\treturn 1;\n\t}\n\n\t// handle writes to the channel keyons\n\tif ((index & 0xf0) == 0xb0)\n\t{\n\t\t*channel = index & 0x0f;\n\t\tif (*channel < 9)\n\t\t{\n            *channel += 9 * opl_emu_bitfield(index, 8,1);\n\t\t\t*opmask = opl_emu_bitfield(data, 5,1) ? 15 : 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}", "void opl_emu_write( struct opl_emu_t* emu, uint16_t regnum, uint8_t data)\n{\n\t// special case: writes to the mode register can impact IRQs;\n\t// schedule these writes to ensure ordering with timers\n\tif (regnum == OPL_EMU_REGISTERS_REG_MODE)\n\t{\n//\t\temu->m_intf.opl_emu_sync_mode_write(data);\n\t\treturn;\n\t}\n\n\t// for now just mark all channels as modified\n\temu->m_modified_channels = OPL_EMU_REGISTERS_ALL_CHANNELS;\n\n\t// most writes are passive, consumed only when needed\n\tuint32_t keyon_channel;\n\tuint32_t keyon_opmask;\n\tif (opl_emu_registers_write(&emu->m_regs,regnum, data, &keyon_channel, &keyon_opmask))\n\t{\n\t\t// handle writes to the keyon register(s)\n\t\tif (keyon_channel < OPL_EMU_REGISTERS_CHANNELS)\n\t\t{\n\t\t\t// normal channel on/off\n\t\t\topl_emu_fm_channel_keyonoff(&emu->m_channel[keyon_channel],keyon_opmask, OPL_EMU_KEYON_NORMAL, keyon_channel);\n\t\t}\n\t\telse if (OPL_EMU_REGISTERS_CHANNELS >= 9 && keyon_channel == OPL_EMU_REGISTERS_RHYTHM_CHANNEL)\n\t\t{\n\t\t\t// special case for the OPL rhythm channels\n\t\t\topl_emu_fm_channel_keyonoff(&emu->m_channel[6],opl_emu_bitfield(keyon_opmask, 4,1) ? 3 : 0, OPL_EMU_KEYON_RHYTHM, 6);\n\t\t\topl_emu_fm_channel_keyonoff(&emu->m_channel[7],opl_emu_bitfield(keyon_opmask, 0,1) | (opl_emu_bitfield(keyon_opmask, 3,1) << 1), OPL_EMU_KEYON_RHYTHM, 7);\n\t\t\topl_emu_fm_channel_keyonoff(&emu->m_channel[8],opl_emu_bitfield(keyon_opmask, 2,1) | (opl_emu_bitfield(keyon_opmask, 1,1) << 1), OPL_EMU_KEYON_RHYTHM, 8);\n\t\t}\n\t}\n}", "void oplregwr( opl_t* opl, uint16_t reg, uint8_t data ) {\n    opl_emu_write( &opl->opl_emu, reg, data );\n}", "static void calc_vol(unsigned char *regbyte, int volume) {\n  int level;\n  /* invert bits and strip out the KSL header */\n  level = ~(*regbyte);\n  level &= 0x3f;\n\n  /* adjust volume */\n  level = (level * volume) / 127;\n\n  /* boundaries check */\n  if (level > 0x3f) level = 0x3f;\n  if (level < 0) level = 0;\n\n  /* invert the bits, as expected by the OPL registers */\n  level = ~level;\n  level &= 0x3f;\n\n  /* final result computation */\n  *regbyte &= 0xC0;  /* zero out all attentuation bits */\n  *regbyte |= level; /* fill in the new attentuation value */\n}", "void opl_noteoff(opl_t* opl, unsigned short voice) {\n  /* if voice is one of the OPL3 set, adjust it and route over secondary OPL port */\n  if (voice >= 9) {\n    oplregwr(opl, 0x1B0 + voice - 9, 0);\n  } else {\n    oplregwr(opl, 0xB0 + voice, 0);\n  }\n}", "void opl_noteon(opl_t* opl, unsigned short voice, unsigned int note, int pitch) {\n  unsigned int freq = freqtable[note];\n  unsigned int octave = octavetable[note];\n\n  if (pitch != 0) {\n    if (pitch > 127) {\n      pitch = 127;\n    } else if (pitch < -128) {\n      pitch = -128;\n    }\n    freq = ((unsigned long)freq * pitchtable[pitch + 128]) >> 15;\n    if (freq >= 1024) {\n      freq >>= 1;\n      octave++;\n    }\n  }\n  if (octave > 7) octave = 7;\n\n  /* if voice is one of the OPL3 set, adjust it and route over secondary OPL port */\n  if (voice >= 9) {\n    voice -= 9;\n    voice |= 0x100;\n  }\n\n  oplregwr(opl, 0xA0 + voice, freq & 0xff); /* set lowfreq */\n  oplregwr(opl, 0xB0 + voice, (freq >> 8) | (octave << 2) | 32); /* KEY ON + hifreq + octave */\n}", "static void voicevolume(opl_t* opl, unsigned short voice, const opl_timbre_t* timbre, int volume) {\n  unsigned char carrierval = timbre->carrier_40;\n  if (volume == 0) {\n    carrierval |= 0x3f;\n  } else {\n    calc_vol(&carrierval, volume);\n  }\n  oplregwr(opl, 0x40 + op2offsets[voice], carrierval);\n}", "void opl_loadinstrument(opl_t* opl, int voice, opl_timbre_t *timbre) {\n  /* KSL (key level scaling) / attenuation */\n  oplregwr(opl, 0x40 + op1offsets[voice], timbre->modulator_40);\n  oplregwr(opl, 0x40 + op2offsets[voice], timbre->carrier_40 | 0x3f); /* force volume to 0, it will be reajusted during 'note on' */\n\n  /* select waveform on both operators */\n  oplregwr(opl, 0xE0 + op1offsets[voice], timbre->modulator_E862 >> 24);\n  oplregwr(opl, 0xE0 + op2offsets[voice], timbre->carrier_E862 >> 24);\n\n  /* sustain / release */\n  oplregwr(opl, 0x80 + op1offsets[voice], (timbre->modulator_E862 >> 16) & 0xff);\n  oplregwr(opl, 0x80 + op2offsets[voice], (timbre->carrier_E862 >> 16) & 0xff);\n\n  /* attack rate / decay */\n  oplregwr(opl, 0x60 + op1offsets[voice], (timbre->modulator_E862 >> 8) & 0xff);\n  oplregwr(opl, 0x60 + op2offsets[voice], (timbre->carrier_E862 >> 8) & 0xff);\n\n  /* AM / vibrato / envelope */\n  oplregwr(opl, 0x20 + op1offsets[voice], timbre->modulator_E862 & 0xff);\n  oplregwr(opl, 0x20 + op2offsets[voice], timbre->carrier_E862 & 0xff);\n\n  /* feedback / connection */\n  if (voice >= 9) {\n    voice -= 9;\n    voice |= 0x100;\n  }\n  if (opl->opl3 != 0) { /* on OPL3 make sure to enable LEFT/RIGHT unmute bits */\n    oplregwr(opl, 0xC0 + voice, timbre->feedconn | 0x30);\n  } else {\n    oplregwr(opl, 0xC0 + voice, timbre->feedconn);\n  }\n\n}", "static int getinstrument(opl_t* opl, int channel, int note) {\n  if ((note < 0) || (note > 127) || (channel > 15)) return(-1);\n  if (channel == 9) { /* the percussion channel requires special handling */\n    if (opl->is_op2)\n      return 128 + note - 35;\n    else\n      return(128 | note);\n  }\n  return(opl->channelprog[channel]);\n}", "void opl_midi_noteoff_op2(opl_t* opl, int channel, int note, int vindex) {\n  int voice = opl->notes2voices[channel][note][vindex];\n\n  if (voice >= 0) {\n    opl_noteoff(opl, voice);\n    opl->voices2notes[voice].channel = -1;\n    opl->voices2notes[voice].note = -1;\n    opl->voices2notes[voice].priority = -1;\n    opl->voices2notes[voice].voiceindex = 0xFF;\n    opl->notes2voices[channel][note][vindex] = -1;\n  }\n}", "void opl_midi_noteon_op2(opl_t* opl, int channel, int note, int velocity, int vindex) {\n  if( velocity == 0 ) {\n      opl_midi_noteoff_op2( opl, channel, note, vindex );\n      return;\n  }\n  int x, voice = -1;\n  int lowestpriority = 0xFFFF;\n  int highestvoiceindex = -1;\n  int lowestpriorityvoice = -1;\n  int instrument;\n\n  /* get the instrument to play */\n  instrument = getinstrument(opl, channel, note);\n  if (instrument < 0) return;\n  \n  /* only play OP2 second voice when appropriate */\n  if (vindex > 0 && (opl->op2_flags[instrument] & OP2_DOUBLEVOICE) == 0) return;\n  \n  opl_timbre_t* timbre = vindex == 0 ? &(opl->opl_gmtimbres[instrument]) : &(opl->opl_gmtimbres_voice2[instrument]);\n\n  /* if note already playing, then reuse its voice to avoid leaving a stuck voice */\n  if (opl->notes2voices[channel][note][vindex] >= 0) {\n    voice = opl->notes2voices[channel][note][vindex];\n  } else {\n    /* else find a free voice, possibly with the right timbre, or at least locate the oldest note */\n    for (x = 0; x < voicescount; x++) {\n      if (opl->voices2notes[x].channel < 0) {\n        voice = x; /* preselect this voice, but continue looking */\n        /* if the instrument is right, do not look further */\n        if (opl->voices2notes[x].timbreid == instrument && opl->voices2notes[x].voiceindex == vindex) {\n          break;\n        }\n      }\n      if (opl->voices2notes[x].priority < lowestpriority) {\n        /* 2nd instrumental voice should not overwrite 1st instrumental voice */\n        /* also prefer 2nd instrumental voices when possible */\n        if (opl->voices2notes[x].voiceindex >= vindex && opl->voices2notes[x].voiceindex >= highestvoiceindex) {\n          lowestpriorityvoice = x;\n          lowestpriority = opl->voices2notes[x].priority;\n          highestvoiceindex = opl->voices2notes[x].voiceindex;\n        }\n      }\n    }\n    /* if no free voice available, then abort the oldest one */\n    if (voice < 0) {\n      if (lowestpriorityvoice < 0) {\n        /* no suitable voice found to abort */\n        return;\n      }\n      voice = lowestpriorityvoice;\n      opl_midi_noteoff_op2(opl, opl->voices2notes[voice].channel, opl->voices2notes[voice].note, opl->voices2notes[voice].voiceindex);\n    }\n  }\n\n  /* load the proper instrument, if not already good */\n  if (opl->voices2notes[voice].timbreid != instrument) {\n    opl->voices2notes[voice].timbreid = instrument;\n    opl_loadinstrument(opl, voice, timbre);\n  }\n\n  /* update states */\n  opl->voices2notes[voice].channel = channel;\n  opl->voices2notes[voice].note = note;\n  opl->voices2notes[voice].priority = ((16 - channel) << 8) | 0xff; /* lower channels must have priority */\n  opl->voices2notes[voice].voiceindex = vindex;\n  opl->notes2voices[channel][note][vindex] = voice;\n  \n  /* second OP2 voice has lower priority */\n  if (vindex != 0) {\n    int reducedprio = (int)opl->voices2notes[voice].priority - OP2_2NDVOICE_PRIORITY_PENALTY;\n    if (reducedprio < 0) reducedprio = 0;\n    opl->voices2notes[voice].priority = (unsigned short)reducedprio;\n  }\n\n  /* set the requested velocity on the voice */\n  voicevolume(opl, voice, timbre, velocity * opl->channelvol[channel] / 127);\n\n  /* trigger NOTE_ON on the OPL, take care to apply the 'finetune' pitch correction, too */\n  if (channel == 9) { /* percussion channel doesn't provide a real note, so I */\n                      /* use a static one (MUSPLAYER uses C-5 (60), why not.  */\n    opl_noteon(opl, voice, timbre->notenum + timbre->noteoffset, opl->channelpitch[channel] + timbre->finetune);\n  } else {\n    opl_noteon(opl, voice, note + timbre->noteoffset, opl->channelpitch[channel] + timbre->finetune);\n  }\n\n  /* reajust all priorities */\n  for (x = 0; x < voicescount; x++) {\n    if (opl->voices2notes[x].priority > 0) opl->voices2notes[x].priority -= 1;\n  }\n}", "void opl_midi_noteon(opl_t* opl, int channel, int note, int velocity) {\n  /* play 2nd instrumental voice first just in case */\n  opl_midi_noteon_op2(opl, channel, note, velocity, 1);\n  opl_midi_noteon_op2(opl, channel, note, velocity, 0);\n}"], "Enums": ["enum opl_emu_envelope_state\n{\n\tOPL_EMU_EG_ATTACK = 1,\n\tOPL_EMU_EG_DECAY = 2,\n\tOPL_EMU_EG_SUSTAIN = 3,\n\tOPL_EMU_EG_RELEASE = 4,\n\tOPL_EMU_EG_STATES = 6\n};", "enum opl_emu_keyon_type\n{\n\tOPL_EMU_KEYON_NORMAL = 0,\n\tOPL_EMU_KEYON_RHYTHM = 1,\n\tOPL_EMU_KEYON_CSM = 2\n};", "enum op2_flags_t {\n  OP2_FIXEDPITCH = 1,\n  OP2_UNUSED = 2, /* technically delayed vibrato https://moddingwiki.shikadi.net/wiki/OP2_Bank_Format */\n  OP2_DOUBLEVOICE = 4,\n};"]}